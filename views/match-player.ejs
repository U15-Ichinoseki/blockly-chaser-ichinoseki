<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Blockly CHaser</title>
  <link rel="icon" href="/images/favicon.ico">
  <link rel='stylesheet' href='/stylesheets/match-player.css' />

  <script src="/socket.io/socket.io.js"></script>
  <script src="/javascripts/blockly/blockly_compressed.js"></script>
  <script src="/javascripts/blockly/blocks_compressed.js"></script>

  <script src="/javascripts/blocks/chaser_block.js"></script>

  <script src="/javascripts/blockly/generators/javascript_compressed.js"></script>
  <script src="/javascripts/generators/javascript_chaser.js"></script>

  <script src="/javascripts/acorn_interpreter.js"></script>

  <script src="/javascripts/match-player.js"></script>

  <script src="/javascripts/code-match.js"></script>
  <script src="/javascripts/match_client.js"></script>

</head>

<body>
  <div class="uploadButton">
    <div class="uploadButton_text">ファイルを選択</div>
      <input id="xml_input" type="file" accept="application/zip,.blch,.json,.xml" onchange="uv.style.display='inline-block'; uv.value = this.value;" />
    <input type="text" id="uv" class="uploadValue" disabled />
  </div>
  <div id="releaseButton" class="release_off">開放</div>
  <div id="content_blocks" class="none_content"></div>

  <script src="/javascripts/fflate.js"></script>
  <script>
    document.getElementById("xml_input").addEventListener('change', function (e) {
      const file = e.target.files[0];
      if (!file) return;

      Code.stopJS();
      
      const fileName = file.name.toLowerCase();
      const reader = new FileReader();
      
      // XMLファイルとして読み込む場合
      if (fileName.endsWith(".xml")) {
        reader.onload = function (e) {
          const xmlText = e.target.result.toString();
          try {
            var xml = Blockly.utils.xml.textToDom(xmlText);
            for (var xml_one of xml.getElementsByTagName("block")) {
              if (xml_one.getAttribute("type") === "server_join") {
                if (query_list.room_id) {
                  let hasRoomToken = false;

                  for (var field of xml_one.getElementsByTagName("field")) {
                    if (field.getAttribute("name") === "room_id") {
                      field.textContent = query_list.room_id;
                    }
                    if (field.getAttribute("name") === "room_token") {
                      field.textContent = query_list.room_token;
                      hasRoomToken = true;
                    }
                  }
                  // room_token が存在しなかった場合、新規作成
                  if (!hasRoomToken) {
                    const newField = xml_one.ownerDocument.createElement("field");
                    newField.setAttribute("name", "room_token");
                    newField.textContent = query_list.room_token;
                    xml_one.appendChild(newField);
                  }
                }

              }
            }
          } catch (e) {
            alert(e);
            return;
          }
          Code.workspace.clear();
          Blockly.Xml.domToWorkspace(xml, Code.workspace);

          Code.runJS();
        };
        reader.readAsText(file);
      }
      // ZIP圧縮JSONとして読み込む場合（.blch や .zip）
      else if (fileName.endsWith(".json")) {
        reader.onload = function (e) {
          const jsonText = e.target.result.toString();
          let workspaceData;

          try {
            workspaceData = JSON.parse(jsonText);

            const blockArray =
              workspaceData?.blocks?.blocks || workspaceData?.blocks || [];

            if (Array.isArray(blockArray)) {
              for (const block of blockArray) {
                if (block.type === "server_join" && query_list.room_id) {
                  block.fields.room_id = query_list.room_id;
                  block.fields.room_token = query_list.room_token;
                }
              }
            } else {
              console.warn("ブロック配列が見つかりませんでした");
            }
          } catch (err) {
            alert("JSONファイルの読み込みまたは解析に失敗しました");
            console.error(err);
            return;
          }

          // Blockly に反映して実行
          Code.workspace.clear();
          Blockly.serialization.workspaces.load(workspaceData, Code.workspace);

          Code.runJS();
        };
        reader.readAsText(file);
      }
      // ZIP圧縮JSONとして読み込む場合（.blch や .zip）
      else {
        reader.onload = function (e) {
          var jsonText
          try {
            const arrayBuffer = e.target.result;
            const uint8 = new Uint8Array(arrayBuffer); 
            const unzipped = fflate.unzipSync(uint8);

            if (!unzipped["program.json"]) {
              alert("program.json が ZIP 内に見つかりませんでした");
              return;
            }

            jsonText = new TextDecoder("utf-8").decode(unzipped["program.json"]);
          } catch (err) {
            alert("ZIPファイルの展開に失敗しました");
            console.error(err);
          }

          let workspaceData;
          try {
            workspaceData = JSON.parse(jsonText);

            const blockArray =
              workspaceData?.blocks?.blocks || workspaceData?.blocks || [];

            if (Array.isArray(blockArray)) {
              for (const block of blockArray) {
                if (block.type === "server_join" && query_list.room_id) {
                  block.fields.room_id = query_list.room_id;
                  block.fields.room_token = query_list.room_token;
                }
              }
            } else {
              console.warn("ブロック配列が見つかりませんでした");
            }
          } catch (err) {
            alert("JSONファイルの読み込みまたは解析に失敗しました");
            console.error(err);
            return;
          }

          // Blockly に反映して実行
          Code.workspace.clear();
          Blockly.serialization.workspaces.load(workspaceData, Code.workspace);

          Code.runJS();
        };
        reader.readAsArrayBuffer(file);
      }
    });

    document.getElementById("releaseButton").onclick = function () {
      Code.stopJS();
      var releaseButton = document.getElementById("releaseButton")
      if (!releaseButton.classList.contains("release_on")) {
        releaseButton.classList.add("release_on");
        if (query_list.key && query_list.chara) {
          socket.emit('release', { "key": query_list.key, "room_id": query_list.room_id, "chara": query_list.chara });
        }
        releaseButton.textContent = "開放中"
      }
    }

  </script>
  <script src="/javascripts/encode_match.js"></script>
  <xml xmlns="https://developers.google.com/blockly/xml" id="toolbox" style="display: none">
    <category name="%{BKY_CATVARIABLES}" colour="%{BKY_VARIABLES_HUE}" custom="VARIABLE"></category>
    <category name="%{BKY_CATFUNCTIONS}" colour="%{BKY_PROCEDURES_HUE}" custom="PROCEDURE"></category>
  </xml>
</body>

</html>